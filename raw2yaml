import argparse
import re
from pathlib import Path
from datetime import datetime
import yaml

# --- YAML에서 멀티라인을 항상 '|' 블록 스타일로 ---
def _str_presenter(dumper, data):
    if isinstance(data, str) and ("\n" in data or len(data) > 80):
        return dumper.represent_scalar("tag:yaml.org,2002:str", data, style="|")
    return dumper.represent_scalar("tag:yaml.org,2002:str", data)
yaml.add_representer(str, _str_presenter)

# SOURCE 라벨 매핑 (파일 내 섹션 헤더를 표준 키로 정규화)
SOURCE_KEY_MAP = {
    "의약품안전나라": "mfds_raw",
    "UpToDate / Lexidrug": "uptodate_lexidrug_raw",
    "UpToDate": "uptodate_lexidrug_raw",
    "Lexidrug": "uptodate_lexidrug_raw",
    "건강보험심사평가원": "hira_raw",
    "HIRA": "hira_raw",
}

SOURCE_HEADER_RE = re.compile(r"^===\s*SOURCE:\s*(.+?)\s*===\s*$", re.MULTILINE)
ID_RE       = re.compile(r"^#\s*id:\s*(.+?)\s*$", re.MULTILINE | re.IGNORECASE)
GENERIC_RE  = re.compile(r"^#\s*generic:\s*(.+?)\s*$", re.MULTILINE | re.IGNORECASE)

FILENAME_RE = re.compile(
    r"^(?P<date>\d{8})_(?P<time>\d{6})_(?P<id>[A-Z]\d{2}[A-Z]{2}\d{2})_(?P<generic>.+)$"
)

def sanitize_filename(s: str) -> str:
    s = s.strip().lower()
    s = s.replace(" ", "_")
    s = re.sub(r"[^a-z0-9_]+", "_", s)
    s = re.sub(r"_+", "_", s).strip("_")
    return s

def parse_header(text: str, fallback_name: str):
    drug_id = None
    generic = None

    m = ID_RE.search(text)
    if m:
        drug_id = m.group(1).strip()

    m = GENERIC_RE.search(text)
    if m:
        generic = m.group(1).strip()

    if not (drug_id and generic):
        # 파일명에서 보정 (예: 20250902_235910_J01DD62_cefoperazone sodium_sulbactam sodium.txt)
        name = Path(fallback_name).stem
        m2 = FILENAME_RE.match(name)
        if m2:
            if not drug_id:
                drug_id = m2.group("id")
            if not generic:
                generic = m2.group("generic").replace("_", " ").strip()

    return drug_id, generic

def split_sources(text: str):
    """
    파일 본문을 '=== SOURCE: XXX ===' 구분자로 분할하여 dict로 반환
    """
    chunks = {}
    matches = list(SOURCE_HEADER_RE.finditer(text))

    if not matches:
        # SOURCE 구분자가 없는 경우, 전체를 unknown_raw로
        chunks["unknown_raw"] = text.strip()
        return chunks

    for i, m in enumerate(matches):
        label = m.group(1).strip()
        start = m.end()
        end = matches[i + 1].start() if i + 1 < len(matches) else len(text)
        body = text[start:end].strip()

        key = SOURCE_KEY_MAP.get(label, f"source__{sanitize_filename(label)}")
        # 중복 키 방지 (동일 SOURCE가 여러 번 있는 경우 suffix)
        original_key = key
        k = 1
        while key in chunks:
            k += 1
            key = f"{original_key}__{k}"

        chunks[key] = body

    return chunks

def build_yaml(drug_id: str, generic: str, sources: dict, source_file: Path):
    now = datetime.utcnow().isoformat(timespec="seconds") + "Z"
    # 기본 스키마(필요한 구조만 남기고 나머지는 후속 요약 파이프라인에서 채움)
    data = {
        "id": drug_id,
        "generic": generic,
        "meta": {
            "source_file": source_file.name,
            "converted_at_utc": now,
            "atc": drug_id,   # id가 ATC코드인 케이스에 한해 그대로 둠
        },
        "raw": sources,       # 원문 저장 (민감 데이터라면 여기서 비식별화/마스킹 로직 추가 가능)
        "brief": "",          # GPT 요약 결과(후속 배치에서 채움)
        "clinical": {
            "indications": "",
            "dosing": {
                "adult": "",
                "pediatric": "",
                "renal_adjustment": "",
                "hepatic_adjustment": "",
            },
            "contraindications": "",
            "warnings": "",
            "adverse_reactions": "",
            "interactions": "",
            "monitoring": "",
        },
        "dur": {
            "pregnancy": "",
            "lactation": "",
            "contra_combo": [],
            "caution_combo": [],
        },
        "notes": "",
    }
    return data

def convert_file(path: Path, out_dir: Path):
    text = path.read_text(encoding="utf-8-sig", errors="ignore")
    drug_id, generic = parse_header(text, path.name)

    if not drug_id or not generic:
        print(f"[WARN] ID/Generic 파싱 실패: {path.name}")
        # 그래도 진행은 하되 unknown_*로 표기
        drug_id = drug_id or "UNKNOWN_ID"
        generic = generic or "UNKNOWN_GENERIC"

    sources = split_sources(text)
    y = build_yaml(drug_id, generic, sources, path)

    # 파일명: <id>_<generic>.yaml
    out_name = f"{sanitize_filename(drug_id)}_{sanitize_filename(generic)}.yaml"
    out_path = out_dir / out_name
    out_dir.mkdir(parents=True, exist_ok=True)

    with out_path.open("w", encoding="utf-8") as f:
        yaml.dump(y, f, allow_unicode=True, sort_keys=False, width=1000)

    return out_path

def main():
    parser = argparse.ArgumentParser(description="Convert raw drug .txt files to YAML.")
    parser.add_argument(
        "--in_dir",
        default=r"C:\Users\USER\OneDrive\raw",
        help="입력 폴더 (raw txt 위치)",
    )
    parser.add_argument(
        "--out_dir",
        default=None,
        help="출력 폴더 (기본: 입력 폴더 상위의 'yaml')",
    )
    args = parser.parse_args()

    in_dir = Path(args.in_dir)
    if args.out_dir:
        out_dir = Path(args.out_dir)
    else:
        out_dir = in_dir.parent / "yaml"

    txt_files = sorted(in_dir.rglob("*.txt"))
    if not txt_files:
        print(f"[INFO] 입력 폴더에 txt가 없습니다: {in_dir}")
        return

    print(f"[INFO] 변환 시작: {len(txt_files)}개 파일")
    for p in txt_files:
        try:
            out_path = convert_file(p, out_dir)
            print(f"[OK] {p.name} -> {out_path.name}")
        except Exception as e:
            print(f"[ERROR] {p.name}: {e}")

if __name__ == "__main__":
    main()
